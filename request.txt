Как лучше реализовать обновление любого меню при получении UserData, я так понимаю надо
реализовывать через меню-подписчиков(те меню, которые зависят от данных пользователя) в MenuUpdaterService?

Есть так же проблема, при получении избранных монет пользователя изменяются не только монеты в меню
CoinSelectionMenu, но и так же кнопки управления, например, кнопка Back и Edit Coins, как лучше реализовать
данную обработку, добавлять определенный префикс к таким кнопкам в CallbackData или как-то по другому?

@Log4j2
@Component
public class UpsertUserResponseHandler extends BaseResponseHandler<UpsertUserResponse> {

    @Value("${spring.rabbitmq.template.routing-key.upsert_user_response}")
    private String UPSERT_USER_RESPONSE_ROUTING_KEY;

    @Value("${menu.coin_selection.prefix[0].coin}")
    private String COIN_PREFIX;

    @Value("${menu.coin_selection.prefix[1].currency}")
    private String CURRENCY_PREFIX;

    @Value("${menu.coin_selection.name}")
    private String COIN_SELECTIONS_MENU_NAME;

    private final MenuUpdaterService menuUpdaterService;

    @Autowired
    public UpsertUserResponseHandler(MenuUpdaterService menuUpdaterService) {
        this.menuUpdaterService = menuUpdaterService;
    }

    @Override
    public boolean canHandle(String routingKey) {
        return UPSERT_USER_RESPONSE_ROUTING_KEY.equals(routingKey);
    }

    @Override
    public HandlerResult handle(ServiceMessage<UpsertUserResponse> serviceMessage) {
        UpsertUserResponse response = serviceMessage.getData();
        boolean responseStatus = response.isSuccess();
        UserDto user = response.getUser();
        if (user == null) {
            log.error("User data is missing in the upsert user response");
            return new HandlerResult.NoResponse();
        }
        logByResponseStatus(responseStatus, user);
        if (responseStatus) {
            processResponse(response);
        }
        return new HandlerResult.NoResponse();
    }

    private void processResponse(UpsertUserResponse response) {
        List<FavoriteCoinDto> favoriteCoins = response.getFavoriteCoins();
        String menuSectionsConfig = buildMenuSectionsConfig(favoriteCoins);
        menuUpdaterService.updateMenuSections(COIN_SELECTIONS_MENU_NAME, menuSectionsConfig);
    }

    private String buildMenuSectionsConfig(List<FavoriteCoinDto> favoriteCoins) {
        return favoriteCoins.stream()
                .map(favoriteCoin -> {
                    CoinDto coin = favoriteCoin.getCoin();
                    String coinName = coin.getName();
                    String coinNamWithPrefixes = COIN_PREFIX + coinName + CURRENCY_PREFIX;
                    return String.format("%s:%s", coinNamWithPrefixes, coinName);
                }).collect(Collectors.joining(","));
    }

    private void logByResponseStatus(boolean status, UserDto user) {
        String telegramId = user.getTelegramId().toString();
        String logMessage = status
                ? "The user's data [user_telegram_id = {}] previously existed in the database. Updating the menu fields."
                : "The user's data [user_telegram_id = {}] did not exist in the database before.";
        log.info(logMessage, telegramId);
    }
}


@Log4j2
@Component
public class MenuUpdaterService {

    private final MenuRegistry menuRegistry;

    private final Map<String, UserDataDependentMenu> userDataDependentMenus = new ConcurrentHashMap<>();


    @Autowired
    public MenuUpdaterService(MenuRegistry menuRegistry) {
        this.menuRegistry = menuRegistry;
    }

    public void updateMenuSections(String menuName, String sectionsConfig) {
        Menu menu = menuRegistry.getMenu(menuName);
        if (menu instanceof BaseMenu baseMenu) {
            baseMenu.updateSections(sectionsConfig);
        } else {
            handleNotSupportedUpdatesSections(menuName);
        }
    }

    private void handleNotSupportedUpdatesSections(String menuName) {
        log.error("Menu \"{}\" does not support section update", menuName);
        throw new NotSupportedUpdateMenuSectionsConfigException(menuName);
    }
}


@Log4j2
@Component
public class KeyboardFactory {

    @Value("${menu.action.back}")
    private String ACTION_BACK;

    private List<InlineKeyboardButton> createButtonsBySections(Map<String, String> sections) {
        return sections.entrySet().stream()
                .map(entry -> InlineKeyboardButton.builder()
                            .text(entry.getValue())
                            .callbackData(entry.getKey())
                            .build()
                ).collect(Collectors.toList());
    }

    public InlineKeyboardMarkup create(Map<String, String> sections, int buttonsPerRow, List<String> fullWidthSections) {

        List<InlineKeyboardRow> rows = new ArrayList<>();
        List<InlineKeyboardButton> buttons = createButtonsBySections(sections);
        Set<String> fullWidthSectionsSet = new HashSet<>(fullWidthSections);

        AtomicReference<InlineKeyboardButton> backButtonRef = new AtomicReference<>();

        for (int i = 0; i < buttons.size(); i += buttonsPerRow) {
            int endIndex = Math.min(i + buttonsPerRow, buttons.size());
            List<InlineKeyboardButton> rowButtons = new ArrayList<>(buttons.subList(i, endIndex));

            rowButtons.removeIf(button -> {
                if (ACTION_BACK.equals(button.getCallbackData())) {
                    backButtonRef.set(button);
                    return true;
                }
                return false;
            });
            Map<Boolean, List<InlineKeyboardButton>> partitioned = rowButtons.stream()
                    .collect(Collectors.partitioningBy(button -> fullWidthSectionsSet.contains(button.getCallbackData())));

            if (!partitioned.get(false).isEmpty()) {
                rows.add(new InlineKeyboardRow(partitioned.get(false)));
            }
            partitioned.get(true).forEach(button -> rows.add(new InlineKeyboardRow(button)));
        }
        InlineKeyboardButton backButton = backButtonRef.get();
        if (backButton != null) {
            rows.add(new InlineKeyboardRow(backButton));
        }
        return new InlineKeyboardMarkup(rows);
    }

    public void change(
            InlineKeyboardMarkup keyboard, Map<String, String> sections
    ) {
        List<InlineKeyboardRow> rows = keyboard.getKeyboard();
        Iterator<Map.Entry<String, String>> sectionsIterator = sections.entrySet().iterator();

        for (int i = 0; i < rows.size(); i++) {
            InlineKeyboardRow currentRow = rows.get(i);
            for (int j = 0; j < currentRow.size(); j++) {

                InlineKeyboardButton currentButton = currentRow.get(j);
                String currentCallbackData = currentButton.getCallbackData();

                if (sectionsIterator.hasNext()) {
                    Map.Entry<String, String> section = sectionsIterator.next();
                    currentButton.setText(section.getValue());
                    currentButton.setCallbackData(section.getKey());
                } else {
                    if (!ACTION_BACK.equals(currentCallbackData)) {
                        currentRow.remove(j);
                        --j;
                    }
                    if (currentRow.isEmpty()) {
                        rows.remove(i);
                        --i;
                    }
                }
            }
        }
    }
}


@Log4j2
@Component
public class MenuSectionTransferService {

    private final List<BaseMenuSectionTransfer> transfers;

    @Autowired
    public MenuSectionTransferService(List<BaseMenuSectionTransfer> transfers) {
        this.transfers = transfers;
    }

    public void performTransfer(Class<? extends BaseMenuSectionTransfer> transferClass) {
        transfers.stream()
                .filter(transfer -> transfer.getClass().equals(transferClass))
                .findFirst()
                .ifPresentOrElse(
                        BaseMenuSectionTransfer::perform,
                        () -> { throw hanleMenuSectionTransferNotFoundException(transferClass); }
                );
    }

    private MenuSectionTransferNotFoundException hanleMenuSectionTransferNotFoundException(
            Class<? extends BaseMenuSectionTransfer> nonExistentTransferClass
    ) {
        String className = nonExistentTransferClass.getSimpleName();
        log.error("Menu section transfer was not found. Non-existent transfer: \"{}\"", className);
        throw new MenuSectionTransferNotFoundException(className);
    }
}


@Component
public abstract class BaseMenuSectionTransfer {

    private final MenuSectionExtractor sectionExtractor;
    private final MenuRegistry menuRegistry;

    protected String sourceMenuName, targetMenuName;
    protected Predicate<? super InlineKeyboardButton> buttonFilter;
    protected String prefixButtonText, prefixCallbackData;

    @Autowired
    public BaseMenuSectionTransfer(MenuSectionExtractor sectionExtractor, MenuRegistry menuRegistry) {
        this.sectionExtractor = sectionExtractor;
        this.menuRegistry = menuRegistry;
    }

    public void perform() {
        Menu sourceMenu = menuRegistry.getMenu(sourceMenuName);
        Menu targetMenu = menuRegistry.getMenu(targetMenuName);

        InlineKeyboardMarkup sourceKeyboardMarkup = sourceMenu.getKeyboardMarkup();
        InlineKeyboardMarkup targetKeyboardMarkup = targetMenu.getKeyboardMarkup();

        List<InlineKeyboardRow> transformedSections = sectionExtractor.extractAndTransformSections(
                sourceKeyboardMarkup,
                buttonFilter,
                prefixButtonText,
                prefixCallbackData
        );
        List<InlineKeyboardRow> mergedSections = mergeSectionsWithoutDuplicates(
               targetKeyboardMarkup.getKeyboard(),
               transformedSections
        );
        targetKeyboardMarkup.setKeyboard(mergedSections);
    }

    private List<InlineKeyboardRow> mergeSectionsWithoutDuplicates(
            List<InlineKeyboardRow> currentSections,
            List<InlineKeyboardRow> newSections
    ) {
        Set<String> existedCallbacks = currentSections.stream().
                flatMap(Collection::stream)
                .map(InlineKeyboardButton::getCallbackData)
                .collect(Collectors.toSet());

        List<InlineKeyboardRow> filteredNewSections = newSections.stream()
                .map(row -> {
                    InlineKeyboardRow filteredRow = new InlineKeyboardRow();
                    row.forEach(button -> {
                        if (!existedCallbacks.contains(button.getCallbackData())) {
                            filteredRow.add(button);
                        }
                    });
                    return filteredRow.isEmpty() ? null : filteredRow;
                })
                .filter(Objects::nonNull)
                .toList();
        return Stream.concat(filteredNewSections.stream(), currentSections.stream()).toList();
    }
}


@Component
public class CoinSelectionMenu extends BaseMenu {

    @Value("${menu.coin_selection.name}")
    private String NAME;

    @Value("${menu.coin_selection.title}")
    private String TITLE;

    @Value("${menu.coin_selection.sections}")
    private String MENU_SECTIONS_CONFIG;

    @Value("${menu.coin_selection.max_buttons_per_row}")
    private int MAX_BUTTONS_PER_ROW;

    @Value("${menu.action.open_edit_coin_sections_menu}")
    private String EDIT_COIN_SECTIONS_CALLBACK_DATA;

    @Override
    protected String getSectionsConfig() {
        return MENU_SECTIONS_CONFIG;
    }

    @Override
    protected int getMaxButtonsPerRow() {
        return MAX_BUTTONS_PER_ROW;
    }

    @Override
    protected List<String> getFullWidthSections() {
        return List.of(EDIT_COIN_SECTIONS_CALLBACK_DATA);
    }

    @Override
    public String getTitle() {
        return TITLE;
    }

    @Override
    public String getName() {
        return NAME;
    }
}
